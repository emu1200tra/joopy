class Route:
    '''
    * Route contains information about the HTTP method, path pattern, which content types consumes and
    * produces, etc..
    *
    * Additionally, contains metadata about route return Java type, argument source (query, path, etc..) and
    * Java type.
    *
    * This class contains all the metadata associated to a route. It is like a {@link Class} object
    * for routes.
    *
    * @author edgar
    * @since 2.0.0
    '''
    class Aware:
        '''
        Allows a handler to listen for route metadata.
        @param route Route metadata.
        '''
        def setRoute(self, route:Route):
            pass
    class Decorator(Aware):
        '''
        * Decorates a route handler by running logic before and after route handler. This pattern is
        * also known as Filter.
        *
        * <pre>{@code
        * {
        *   decorator(next -> ctx -> {
        *     long start = System.currentTimeMillis();
        *     Object result = next.apply(ctx);
        *     long end = System.currentTimeMillis();
        *     System.out.println("Took: " + (end - start));
        *     return result;
        *   });
        * }
        * }</pre>
        *
        * @author edgar
        * @since 2.0.0
        '''
        def apply(self, next:Handler) -> Handler:
            '''
            * Chain the decorator within next handler.
            *
            * @param next Next handler.
            * @return A new handler.
            '''
            pass
        def then(self, next):
            '''
            * Chain this decorator with another and produces a new decorator.
            *
            * @param next Next decorator.
            * @return A new decorator.
            '''
            if isinstance(next, Decorator):
               return lambda h : apply(next.apply(h))
            if isinstance(next, Handler):
                return lambda ctx : apply(next).apply(ctx)
    class Before:
        '''
        * Decorates a handler and run logic before handler is executed.
        *
        * @author edgar
        * @since 2.0.0
        '''
        def apply(self, ctx:Context):
            '''            
            * Chain this filter with next one and produces a new before filter.
            *
            * @param next Next decorator.
            * @return A new decorator.
            '''
            raise Exception
        def then(self, next):
            '''
            * Chain this decorator with a handler and produces a new handler.
            *
            * @param next Next handler.
            * @return A new handler.
            * Chain this filter with next one and produces a new before filter.
            *
            * @param next Next decorator.
            * @return A new decorator.
            '''
            def inner_then(self, ctx, next):
                apply(ctx)
                if not ctx.isResponseStarted():
                    return next.apply(ctx)
                return ctx
            return lambda ctx : inner_then(ctx, next)
    class After:
        '''
        * Execute application logic after a response has been generated by a route handler.
        *
        * For functional handler the value is accessible and you are able to modify the response:
        *
        * <pre>{@code
        * {
        *   after((ctx, result) -> {
        *     // Modify response
        *     ctx.setResponseHeader("foo", "bar");
        *     // do something with value:
        *     log.info("{} produces {}", ctx, result);
        *   });
        *
        *   get("/", ctx -> {
        *     return "Functional value";
        *   });
        * }
        * }</pre>
        *
        * For side-effect handler (direct use of send methods, outputstream, writer, etc.) you are not
        * allowed to modify the response or access to the value (value is always <code>null</code>):
        *
        * <pre>{@code
        * {
        *   after((ctx, result) -> {
        *     // Always null:
        *     assertNull(result);
        *
        *     // Response started is set to: true
        *     assertTrue(ctx.isResponseStarted());
        *   });
        *
        *   get("/", ctx -> {
        *     return ctx.send("Side effect");
        *   });
        * }
        * }</pre>
        *
        * @author edgar
        * @since 2.0.0
        '''
        #result: Object, failure: Throwable
        def apply(self, ctx, result, failure):
            '''
            * Chain this filter with next one and produces a new after filter.
            *
            * @param next Next filter.
            * @return A new filter.
            '''
            raise Exception
        def then(self, next):
            '''
            * Execute application logic on a route response.
            *
            * @param ctx Web context.
            * @param result Response generated by route handler.
            * @param failure Uncaught exception generated by route handler.
            * @throws Exception If something goes wrong.
            '''
            def inner_then(self, ctx, result, failure):
                next.apply(ctx, result, failure)
                apply(ctx, result, failure)
            return lambda ctx, result, failure : inner_then(ctx, result, failure)
        
    class Handler(Aware):
        '''
        * Route handler here is where the application logic lives.
        *
        * @author edgar
        * @since 2.0.0
        '''
        def apply(self, ctx):
            '''
            Execute application code.

            @param ctx Web context.
            @return Route response.
            @throws Exception If something goes wrong.
            '''
            raise Exception
        def then(self, next):
            '''
            Chain this after decorator with next and produces a new decorator.

            @param next Next decorator.
            @return A new handler.
            '''
            def inner_then(self, ctx, next):
                value = None
                cause = None
                try:
                    value = apply(ctx)
                except Exception:
                    cause = Exception
                result = None
                try:
                    if ctx.isResponseStarted():
                        result = Context.readOnly(ctx)
                        next.apply(result, value, cause)
                    else:
                        result = value
                        next.apply(ctx, value, cause)
                except Exception:
                    if not cause:
                        cause = Exception
                    else:
                        cause.addSuppressed(Exception)
                
                if not cause:
                    return result
                else:
                    if ctx.isResponseStarted():
                        return ctx
                    else:
                        raise SneakyThrows.propagate(cause)
            return lambda ctx : inner_then(ctx, next)
    """
    Favicon handler as a silent 404 error.
    """
    FAVICON = lambda ctx: ctx.send(StatusCode.NOT_FOUND) # Handler # ctx -> ctx.send(StatusCode.NOT_FOUND);
    __EMPTY_LIST = [] # final # List # Collections.emptyList()
    __EMPTY_MAP = {} # final # Map # Collections.emptyMap()

    """
    Creates a new route.
    @param method HTTP method. (@Nonnull String)
    @param pattern Path pattern. (@Nonnull String)
    @param handler Route handler. (@Nonnull Handler)
    """
    def __init__(self, method, pattern, handler):
        self.__decoders = Route.__EMPTY_MAP # Map<String, MessageDecoder>
        self.__pattern = pattern # final # String
        self.__method = method.upper() # final # String
        self.__pathKeys = Route.__EMPTY_LIST # List<String>
        self.__before = None # Before
        self.__decorator = None # Decorator
        self.__handler = handler # Handler
        self.__after = None # After
        self.__pipeline = None # Handler
        self.__encoder = None # MessageEncoder
        self.__returnType = None # Type
        self.__handle = handler # object
        self.__produces = Route.__EMPTY_LIST # List<MediaType>
        self.__consumes = Route.__EMPTY_LIST # List<MediaType>
        self.__attributes = None # Map<String, Object> # new TreeMap<>(String.CASE_INSENSITIVE_ORDER)
        self.__supportedMethod = None # Set<String>
        self.__executorKey = None # String
        self.__tags = Route.__EMPTY_LIST # List<String>
        self.__summary = None # String
        self.__description = None # String

    def getPattern(self) -> str:
        return self.__pattern

    def getMethod(self) -> str:
        return self.__method

    def getPathKeys(self) -> list[str]:
        return self.__pathKeys

    def setPathKeys(self, pathKeys: list[str]):
        self.__pathKeys = pathKeys
        return self

    def getHandler(self) -> Handler:
        return self.__handler

    def getPipeline(self) -> Handler:
        if self.__pipeline is None:
            self.__pipeline = self.computePipeline()
        return self.__pipeline

    def getBefore(self) -> Before:
        return self.__before

    def setBefore(self, before: Before):
        self.__before = before
        return self

    def getAfter(self):
        return self.__after

    def setAfter(self, after: After):
        self.__after = after
        return self
    
    def getDecorator(self):
        return self.__decorator

    def setDecorator(self, decorator: Decorator):
        self.__decorator = decorator
        return self

    def getEncoder(self) -> MessageEncoder:
        return self.__encoder

    def setEncoder(self, encoder: MessageEncoder):
        self.__encoder = encoder
        return self

    def getReturnType(self): # Type
        return self.__returnType
    
    def setReturnType(self, returnType): # Type
        self.__returnType = returnType
        return self

    def getDecoders(self) -> dict[str, MessageDecoder]:
        return self.__decoders

    def setDecoders(self, decoders: dict[str, MessageDecoder]):
        self.__decoders = decoders
        return self

    def setExecutorKey(self, key: str):
        self.__executorKey = key
        return self

    def getExecutorKey(self) -> str:
        return self.__executorKey

    def setReturnType(self, returntype: object):
        self.__returnType = returntype
        return self

    def getReturnType(self) -> object:
        return self.__returnType

    # TODO: class MediaType is not implemented yet
    def getProduces(self) -> list[MediaType]:
        return self.__produces 
    
    def produces(self, *args) -> Route:
        produces = []
        for produce in args:
            produces.append(produce)
        
        return setProduces(produces)

    def setProduces(self, produces: list[MediaType]) -> Route: # Collection<MediaType> produces
        if len(produces) > 0:
            if self.__produces == __EMPTY_LIST:
                 # new arrayList in java(?)
                pass
            
            for produce in produces:
                self.__produces.append(produce)
            
        return self               

    def getConsumes(self) -> list[MediaType]: 
        return self.__consumes

    def consumes(self, *args) -> Route:
        consumes = []
        for consume in args:
            consumes.append(consume)
        
        return setConsumes(consumes)

    def setConsumes(self, consumes: list[MediaType]) -> Route: # Collection<MediaType> consumes
        # TODO
        if len(consumes) > 0:
            if self.__consumes == __EMPTY_LIST:
                # new arrayList in java(?)
                pass
            
            for consume in consumes:
                self.__consumes.append(consume)
            
        return self
            
    def computePipeline(self) -> Handler:
        pipeline = None # Route.Handler
        if self.__decorator is None:
            pipeline = self.__handler
        else:
            pipeline = self.__decorator.then(self.__handler)

        if self.__before is not None:
            pipeline = self.__before.then(pipeline)
        
        if self.__after is not None:
            pipeline = pipeline.then(self.__after)

        return pipeline
    
    # TODO: ACCEPT, SUPPORT_MEDIA_TYPE
    ACCEPT = Route.Before() # static final Route.Before
    SUPPORT_MEDIA_TYPE = Route.Before() #static final Route.Before
